(ns sigil.refresh
  (:use [fresh.core :only [clj-files-in make-fresh]]
        [clojure.java.io :only [file]])
  (:import [java.util.concurrent ScheduledThreadPoolExecutor TimeUnit]))



(defn files-to-keep-fresh [root]
  (clj-files-in (file root)))

(defn report-refresh [opt-map report]
  (when-let [refreshed-files (seq (:reloaded report))]
    (let [{:keys [dojo-resource koan-resource koan-root]} opt-map
          path-seq (ordered-koan-paths koan-root koan-resource)
          these-koans (filter (among-paths? refreshed-files)
                              path-seq)]
      (when (every? (partial tests-pass? dojo-resource)
                    these-koans)
        (if-let [next-koan-file (file (next-koan-path path-seq
                                                      (last these-koans)))]
          (report-refresh opt-map {:reloaded [next-koan-file]})
          (namaste))))
    (println))
  :refreshed)

(defn refresh!
  [{:keys [koan-root] :as opts}]
  (let [listing-atom (atom {})]
    (fn []
      (try
        (make-fresh listing-atom
                    (files-to-keep-fresh koan-root)
                    (partial report-refresh opts))
        (catch Throwable t
          ;; Fresh `require`s every ns, so ignore macroexpansion failures
          )))))

(def scheduler (ScheduledThreadPoolExecutor. 1))

(defn setup-freshener [koan-map]
  (println "Starting auto-runner...")
  (.scheduleWithFixedDelay scheduler
                           (refresh! koan-map)
                           0 500 TimeUnit/MILLISECONDS)
  (.awaitTermination scheduler Long/MAX_VALUE TimeUnit/SECONDS))
  

